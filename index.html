<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>High-Load Browser Benchmark (Safe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui,Segoe UI,Roboto,Arial; margin: 20px; }
    #controls { display:flex; gap:10px; align-items:center; margin-bottom:10px}
    button { padding:8px 12px; }
    canvas { border:1px solid #ddd; display:block; margin-top:10px; }
    #status { margin-top:8px; color:#333; }
    .chart { width:600px; height:120px; }
  </style>
</head>
<body>
  <h1>High-Load Browser Benchmark â€” Safe Mode</h1>
  <p>Warning & consent: This app will push CPU and GPU heavily. Run only with explicit consent and while plugged into power. The app will refuse to run on battery.</p>

  <div id="controls" style="display:flex; justify-content:center; margin-top:40vh;">
    <button id="start">Start</button>
  </div>

  <div id="status" style="display:none">Idle</div>

  <!-- invisible-but-rendered canvas for GPU work (kept to perform GPU rendering but not visually shown) -->
    <canvas id="gpuCanvas" width="3840" height="2160" style="display:none; position:fixed; left:0; top:0; width:100vw; height:100vh; background:#000; z-index:9998;"></canvas>

<script>
/* -------------------------
   Helper: Battery check
   ------------------------- */
async function checkBatteryOK() {
  if (!('getBattery' in navigator)) return true; // unknown, assume OK
  try {
    const bat = await navigator.getBattery();
    if (!bat.charging && bat.level < 0.9) return false;
    return true;
  } catch (e) { return true; }
}

/* -------------------------
   CPU worker code (string)
   ------------------------- */
const workerCode = `
self.onmessage = function(e) {
  const { cmd, intensity, durationMs, warmupMs, instances } = e.data;
  if (cmd === 'run') {
    const end = performance.now() + durationMs;
    const warmEnd = performance.now() + warmupMs;
    // Setup arrays to avoid GC during test
    const N = 100000;
    let A = new Float64Array(N);
    for (let i=0;i<N;i++) A[i] = (i+1) * 0.000001;
    let ops = 0;
    function heavyStep() {
      const batch = 2000 + Math.floor(intensity * 90);
      for (let b=0;b<batch;b++) {
        // for each logical instance assigned to this worker, do inner work
        for (let inst = 0; inst < (instances || 1); inst++) {
          let s = 0;
          for (let i=0;i<500;i+=5) {
            let v = A[(i*7 + inst) % N];
            v = Math.sqrt(v * (i+1)) * Math.sqrt(v * (i+1)) * Math.sqrt(v * (i+1)) + Math.sin(v) * Math.sqrt(v * (i+1));
            A[(i*3 + inst) % N] = v;
            s += (v * 1.000001) | 0;
          }
          ops++;
        }
      }
      if (performance.now() < warmEnd) {
        // warmup period, don't report
        setTimeout(heavyStep, 0);
      } else if (performance.now() < end) {
        // report progress periodically
        self.postMessage({type:'tick', ops:ops});
        ops = 0;
        setTimeout(heavyStep, 0);
      } else {
        self.postMessage({type:'done'});
      }
    }
    heavyStep();
  }
};
`;

/* -------------------------
   Main app state
   ------------------------- */
let workers = [];
let cpuSamples = []; // per-second aggregated ops
let gpuSamples = []; // per-second frames
let runActive = false;
let gpuFrameCount = 0;
let lastFrameTick = 0;

/* -------------------------
   CPU controller
   ------------------------- */
function spawnWorkers(num, intensity, durationMs, warmupMs, instancesPerWorker) {
  terminateWorkers();
  workers = [];
  for (let i=0;i<num;i++) {
    const blob = new Blob([workerCode], {type: 'application/javascript'});
    const url = URL.createObjectURL(blob);
    const w = new Worker(url);
    w.onmessage = (ev) => {
      if (ev.data.type === 'tick') {
        // accumulate per worker tick
        const ops = ev.data.ops || 0;
        // store into last slot
        if (!cpuSamples.length) cpuSamples.push({t:Date.now(), ops:0});
        cpuSamples[cpuSamples.length-1].ops += ops;
      } else if (ev.data.type === 'done') {
        w.terminate();
      }
    };
    w.postMessage({cmd:'run', intensity:intensity, durationMs:durationMs, warmupMs:warmupMs, instances: instancesPerWorker});
    workers.push(w);
  }
}

function terminateWorkers() {
  for (const w of workers) try { w.terminate(); } catch(e){}
  workers = [];
}

/* -------------------------
   GPU (WebGL) heavy shader
   ------------------------- */
function createGL(canvas) {
  const gl = canvas.getContext('webgl', {antialias:false, preserveDrawingBuffer:false});
  if (!gl) throw new Error('WebGL not supported');
  gl.getExtension('OES_element_index_uint');
  return gl;
}

function makeProgram(gl, vsSource, fsSource) {
  function compile(src, type){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(s));
    }
    return s;
  }
  const vs = compile(vsSource, gl.VERTEX_SHADER);
  const fs = compile(fsSource, gl.FRAGMENT_SHADER);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    throw new Error(gl.getProgramInfoLog(p));
  }
  return p;
}

function createHeavyFragment(loopCount) {
  // loopCount controls the inner loop iterations to scale GPU work
  // The shader below performs multiple kinds of math: rotations, polynomial transforms,
  // Fourier-like additive synth, color mapping and smoothstep blending to make output colorful.
  return `
  precision highp float;
  uniform float u_time;
  uniform vec2 u_res;
  
  // 2D rotate
  mat2 rot(float a){ float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }

  // pseudo-hash
  float hash21(vec2 p){ return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123); }

  // smooth palette
  vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d){
    return a + b * cos(6.28318*(c * t + d));
  }

  uniform float u_idx;
  
  // simple pseudo-random generator per tile
  float prand(float x){ return fract(sin(x*127.1)*43758.5453); }

  // noise / fbm helpers
  float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash21(i);
    float b = hash21(i + vec2(1.0, 0.0));
    float c = hash21(i + vec2(0.0, 1.0));
    float d = hash21(i + vec2(1.0, 1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
  }

  float fbm(in vec2 p){
    float v = 0.0;
    float amp = 0.5;
    for(int i=0;i<6;i++){
      v += amp * noise(p);
      p = p * 2.0 + vec2(0.5,0.2);
      amp *= 0.5;
    }
    return v;
  }

  // HSV helpers
  vec3 rgb2hsv(vec3 c){
    vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0*d + e)), d / (q.x + e), q.x);
  }

  vec3 hsv2rgb(vec3 c){
    vec3 p = abs(fract(c.x + vec3(0.0, 2.0/3.0, 1.0/3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
  }

  // chromatic aberration: shift uv per channel with fbm
  vec3 chroma(vec2 uv, float t, float seed){
    float sh = 0.002 + 0.003 * prand(seed + t);
    float r = fbm((uv + vec2(sh,0.0))*20.0 + t*0.1);
    float g = fbm((uv)*20.0 + t*0.08);
    float b = fbm((uv - vec2(sh,0.0))*20.0 + t*0.06);
    return vec3(r,g,b);
  }

  void main(){
    vec2 uv = (gl_FragCoord.xy / u_res - 0.5) * 2.0; // -1..1
    float aspect = u_res.x / u_res.y;
    uv.x *= aspect;
    vec2 p = uv;
    float T = u_time * 0.001;
    // accumulate multi-scale signals
    float acc = 0.0;
    float acc2 = 0.0;
    vec3 col = vec3(0.0);
    // rotation that slowly changes
    float baseRot = sin(T*0.3)*0.6 + cos(T*0.13)*0.2;
    p = rot(baseRot) * p;
    // Fourier-like additive synthesis using varying frequencies and phases
    for(int i=0;i<${loopCount};i++){
      float fi = float(i) + 1.0;
      // frequency scales with golden ratio like pattern
      float freq = pow(1.3, fi*0.12);
      float phase = hash21(vec2(fi, fi*0.73)) * 6.28318;
      float s = sin((p.x*freq + p.y*freq) * (0.5 + 0.3*sin(T*0.1*fi)) + phase + T*0.2*fi);
      float c = cos((p.y*freq - p.x*freq) * (0.5 + 0.2*cos(T*0.07*fi)) + phase*0.5 - T*0.17*fi);
      // nonlinear fold and softabs to add complexity
      float v = sign(s)*pow(abs(s), 0.9) * (0.7 + 0.3*c);
      acc += v * (1.0/fi);
      acc2 += (s*c) * (0.5/fi);
      // color contribution per band
      col += palette(fract(fi*0.13 + acc*0.02), vec3(0.5), vec3(0.5), vec3(1.0), vec3(0.0)) * (0.02/fi);
      // small local perturbation
      p += 0.001 * vec2(s,c);
    }

    // matrix-style polynomial combination
    float a = acc * 0.6 + acc2 * 0.4;
    float aa = a;
    for(int k=0;k<4;k++) aa = aa*aa*0.5 + 0.1*aa; // iterate a few nonlinear ops

  // make a small 4x4 collage inside each tile
  // map uv from -1..1 to 0..1 local
  vec2 luv = uv * 0.5 + 0.5;
  // small grid
  float gridN = 4.0;
  vec2 cell = floor(luv * gridN);
  vec2 cellUV = fract(luv * gridN) * 2.0 - 1.0; // -1..1 inside cell
  // compute a per-cell variation seeded by tile index and cell coords
  float seed = u_idx * 37.0 + cell.x*7.0 + cell.y*13.0;
  float tone = prand(seed + T*0.1);
  float r = length(cellUV);
  float rings = sin(r*10.0 - T*0.5 + aa*2.0 + tone*6.0);
  float mask = smoothstep(0.25, 0.0, abs(rings));

    // combine base color with palette and band-synth color
    vec3 base = palette(fract(a*0.17 + T*0.01), vec3(0.2,0.25,0.3), vec3(0.8,0.6,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.66));
    col = mix(base, col, 0.7) * (0.6 + 0.4*mask);

    // apply soft vignette
    float vign = smoothstep(1.0, 0.4, r);
    col *= vign;

    // add FBM-based microstructure to increase perceived detail
    float micro = fbm(uv*30.0 + vec2(T*0.02));
    col += 0.12 * vec3(micro);

    // add chromatic aberration via FBM per channel
    vec3 ch = chroma(uv, T*0.1, u_idx);
    col += 0.08 * ch;

    // convert to HSV, boost saturation and vibrance, then back
    vec3 hsv = rgb2hsv(col);
    hsv.y = pow(hsv.y, 0.7) * 1.45; // increase saturation more aggressively
    hsv.z = pow(hsv.z, 0.95);
    col = hsv2rgb(hsv);

    // subtle filmic tone mapping + contrast
    col = col/(col + vec3(1.0));
    col = pow(col, vec3(0.92));

    // add a thin frame between cells like photo borders
    vec2 border = smoothstep(0.04, 0.03, abs(fract(luv*gridN)-0.5));
    float bmask = min(border.x, border.y);
    vec3 framed = mix(vec3(0.06), col, bmask);
    // subtle per-tile tint
    float tint = prand(u_idx*0.123 + 0.42);
    framed *= mix(0.85, 1.15, tint);
    gl_FragColor = vec4(clamp(framed, 0.0, 1.0), 1.0);
  }
  `;
}

/* We'll dynamically generate the fragment shader with a loop count based on user complexity. */

/* -------------------------
   Rendering & measurement
   ------------------------- */
let gl = null;
let program = null;
let timeLoc = null;
let resLoc = null;
let startTime = 0;
let requestedStop = false;

function startGPU(canvas, complexity) {
  if (!gl) gl = createGL(canvas);
  // create simple fullscreen quad
  const vs = `
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
  `;
  const innerLoops = Math.max(1, Math.floor(complexity * 3)); // scale loops
  let fs = createHeavyFragment(10 * innerLoops);
  program = makeProgram(gl, vs, fs);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const posLoc = gl.getAttribLocation(program, 'a_pos');
  gl.enableVertexAttribArray(posLoc);
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
  timeLoc = gl.getUniformLocation(program, 'u_time');
  resLoc = gl.getUniformLocation(program, 'u_res');
  const idxLoc = gl.getUniformLocation(program, 'u_idx');

  startTime = performance.now();
  gpuFrameCount = 0;
  lastFrameTick = 0;
  requestedStop = false;
  // store draws-per-frame (instances) on the program object for the frame loop
  program._instances = program._instances || 1;

  function frame() {
    if (requestedStop) return;
    const t = performance.now() - startTime;
    gl.useProgram(program);
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    // draw many small tiles across the canvas
    const total = Math.max(1, program._instances || 1);
    // compute tile grid (try square-ish)
    const cols = Math.ceil(Math.sqrt(total));
    const rows = Math.ceil(total / cols);
    const tileW = Math.max(1, Math.floor(canvas.width / cols));
    const tileH = Math.max(1, Math.floor(canvas.height / rows));
    let drawn = 0;
    for (let r = 0; r < rows && drawn < total; r++) {
      for (let c = 0; c < cols && drawn < total; c++) {
        const x = c * tileW;
        const y = r * tileH;
        gl.viewport(x, y, tileW, tileH);
        gl.uniform1f(timeLoc, t + drawn * 0.001);
        gl.uniform2f(resLoc, tileW, tileH);
        if (idxLoc) gl.uniform1f(idxLoc, drawn);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        drawn++;
      }
    }
    gpuFrameCount++;
    // collect per-second samples
    if (t - lastFrameTick >= 1000) {
      const framesThisSecond = gpuFrameCount;
      gpuSamples.push({t:Date.now(), fps: framesThisSecond});
      gpuFrameCount = 0;
      lastFrameTick = t;
    }
    // schedule next
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
}

function stopGPU() {
  requestedStop = true;
  // cleanup GL resources lightly
  try {
    if (gl) {
      // gl.getExtension('WEBGL_lose_context')?.loseContext();
    }
  } catch(e){}
}

/* -------------------------
   Chart draw helpers
   ------------------------- */
function drawLineChart(canvas, dataPoints, label, maxY) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = '#fafafa';
  ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = '#333';
  ctx.beginPath();
  const M = dataPoints.length;
  if (M===0) {
    ctx.fillStyle='#666'; ctx.fillText('No data yet',10,20); return;
  }
  const minT = dataPoints[0].t;
  const maxT = dataPoints[dataPoints.length-1].t;
  const rangeT = Math.max(1, maxT - minT);
  for (let i=0;i<M;i++) {
    const x = ((dataPoints[i].t - minT)/rangeT) * (w-40) + 30;
    const val = (dataPoints[i][label] || 0);
    const y = h - 10 - (val / (maxY||Math.max(...dataPoints.map(d=>d[label]||1)))) * (h-30);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
  ctx.fillStyle = '#000';
  ctx.fillText(label.toUpperCase(), 4,12);
}

/* -------------------------
   Orchestration
   ------------------------- */
const startBtn = document.getElementById('start');
const gpuCanvas = document.getElementById('gpuCanvas');

startBtn.addEventListener('click', async () => {
  // battery check removed per user request: allow running on battery
  if (runActive) return;
  // Forced test parameters per request
  const durationMs = 60 * 1000; // 60 seconds
  const intensity = 10; // max on original 1..10 scale
  const shaderComplex = 8; // max on original 1..8 scale
  // reset state
  cpuSamples = [];
  gpuSamples = [];
  runActive = true;
  startBtn.disabled = true;
  status.textContent = 'Warming up (3s)...';
  // spawn workers
  const cores = navigator.hardwareConcurrency || 4;
  const warmupMs = 3000;
  // CPU and GPU instances per new request
  const cpuInstances = 5000;
  const gpuInstances = 5000;
  const instancesPerWorker = Math.max(1, Math.floor(cpuInstances / cores));
  spawnWorkers(cores, intensity, durationMs + warmupMs, warmupMs, instancesPerWorker);
  // start GPU with GPU instance count; set draws per frame to gpuInstances
  // show canvas and start GPU
  gpuCanvas.style.display = 'block';
  startGPU(gpuCanvas, shaderComplex);
  if (program) program._instances = gpuInstances;

  // measurement timer: stop after durationMs
  const startT = Date.now();
  const interval = setInterval(() => {
    const elapsed = Date.now() - startT;
    if (elapsed >= durationMs) {
      clearInterval(interval);
      finalizeRun();
    }
  }, 1000);
});

function finalizeRun(manual=false) {
  runActive = false;
  requestedStop = true;
  terminateWorkers();
  stopGPU();
  startBtn.disabled = false;
  // hide canvas after finishing
  try { document.getElementById('gpuCanvas').style.display = 'none'; } catch(e){}
  // compute aggregate stats
  const cpuOps = cpuSamples.map(s=>s.ops||0);
  const gpuFps = gpuSamples.map(s=>s.fps||0);
  function stats(arr) {
    if (!arr.length) return {sum:0,avg:0,max:0,min:0};
    const sum = arr.reduce((a,b)=>a+b,0);
    return {sum, avg: sum/arr.length, max:Math.max(...arr), min:Math.min(...arr)};
  }
  const cpuStats = stats(cpuOps);
  const gpuStats = stats(gpuFps);
  status.textContent = 'Finished. CPU avg ops/sec: ' + Math.round(cpuStats.avg) + ', GPU avg FPS: ' + (gpuStats.avg?gpuStats.avg.toFixed(1):'0');
}
</script>
</body>
</html>
